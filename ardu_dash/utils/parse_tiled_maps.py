#!/usr/bin/python3

import os
import glob
import json
import datetime

import sys

from typing import List, Dict


DEBUG = False

def log(s: str):
    if DEBUG:
        print(s)

MAP_WIDTH = 20
MAP_HEIGHT = 4


TO_CHARS = {
    0: ' ',
    1: '-',
    2: 'x',
    3: '^'
}

def parse_tiled_map_file(json_map_path: str, indent: int = 2) -> Dict:
    filename_with_ext = os.path.basename(json_map_path)
    log(f"Parsing {filename_with_ext}")
    filename, _ = filename_with_ext.split('.')

    comment_line = f"// {filename_with_ext}\n"

    with open(json_map_path, 'r') as f:
        map_data = json.load(f)
        assert map_data["width"] == MAP_WIDTH, f"map width != {MAP_WIDTH}"
        assert map_data["height"] == MAP_HEIGHT, f"map width != {MAP_HEIGHT}"

        # links are ;-separated level names, that current level can lead to
        links_to_next_lvls = [p["value"] for p in map_data["properties"] if p["name"] == "links"][0]
        obstacle_count = [p["value"] for p in map_data["properties"] if p["name"] == "obstacle_count"][0]
        parse_vertical = [p["value"] for p in map_data["properties"] if p["name"] == "parse_vertical"][0]
        next_map_names = [l for l in links_to_next_lvls.split(';') if l]
        
        lvl_data = map_data["layers"][0]["data"]
        char_lvl_data = ',\n'.join(
            ' '*indent + ''.join(
                [TO_CHARS[c] for c in lvl_data[i:i+MAP_WIDTH]]
            )
            for i in range(0, MAP_HEIGHT*MAP_WIDTH, MAP_WIDTH) 
        )

        char_lvl_data = "{{\n{}\n}}".format(char_lvl_data)
        char_lvl_data = comment_line + char_lvl_data
        return {
            "name": filename,
            "char_data": char_lvl_data,
            "next_maps": next_map_names,
            "obstacle_count": obstacle_count,
            "parse_vertical": parse_vertical,
        }

def parse_tiled_maps_to_c_maps_header_file(maps_folder_path: str) -> str:
    folder_abs_path = os.path.abspath(maps_folder_path)

    maps_files = sorted(glob.glob(folder_abs_path + "/**/*.json", recursive=True))

    content = ""
    raw_parsed_data = [parse_tiled_map_file(map_file) for map_file in maps_files]

    levels_info = {}

    for i, parsed_data in enumerate(raw_parsed_data):
        content += parsed_data["char_data"] + ",\n"
        parsed_data["index"] = i
        levels_info[parsed_data["name"]] = parsed_data

    maps_parsed = len(maps_files)

    constants_definition = ''.join([
        f"// auto-generated by {os.path.basename(__file__)} at {datetime.datetime.now()}\n\n",
        "#pragma once\n\n",
        f"constexpr uint8_t SEGMENT_CNT = {maps_parsed};\n",
        f"constexpr uint8_t SEGMENT_W = {MAP_WIDTH};\n",
        f"constexpr uint8_t SEGMENT_H = {MAP_HEIGHT};\n\n",
    ])
    array_declaration = "const char PROGMEM SEGMENT_MAPS[SEGMENT_CNT][SEGMENT_H][SEGMENT_W] = {\n"
    array_close_bracket = "};\n"

    return constants_definition + array_declaration + content + array_close_bracket, levels_info



if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("[ERROR] Path to folder with csv maps is not provided")
        exit(1)

    path_to_folder = sys.argv[1]

    # TODO: use argparse
    try:
        debug_mode = sys.argv[2]
        if (debug_mode == "debug"):
            DEBUG = True
    except IndexError:
        pass

    copy_paste_ready_char_maps, raw_parase_data = parse_tiled_maps_to_c_maps_header_file(path_to_folder)
    log("\n----COPY PASTE START----\n")
    print(copy_paste_ready_char_maps)
    log("\n----COPY PASTE END------\n")